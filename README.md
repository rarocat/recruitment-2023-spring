# 机器信息

CPU：Intel(R) Xeon(R) Gold 6161 CPU @ 2.20GHz
核数：1 核 2 线程
内存：4 GB
操作系统：Ubuntu 22.04.1 LTS

# 优化结果

```plain
测试数据                   优化前（ms）  优化后（ms）  加速比
1024x1024triangular_0.bin  13401.065     30.788000     435.269098350006
1024x1024symmetric_0.bin   13417.977     24.039000     558.175340072382
1024x1024banded_0.bin      13386.56      17.963000     745.229638701776
1024x1024diagonal_0.bin    13395.819     16.569000     808.486873076227
2048x2048general_0.bin     107040.698    201.284000    531.78940203891
2048x2048banded_0.bin      107092.794    72.048000     1486.40897734843
2048x2048triangular_0.bin  107045.821    197.883000    540.955114891123
1024x1024general_0.bin     13396.943     32.818000     408.219361326102
2048x2048symmetric_0.bin   106996.228    136.793000    782.176193226262
2048x2048diagonal_0.bin    107006.739    69.875000     1531.4023470483
合计                       602180.644    800.06        752.66935479839
```

# 优化思路

## 把 vector 换成 float 数组

发现 vector 动态开内存 & 每次都进行下标检查，很慢，换掉了

## 减少内存复制开销

发现从 float 构造 vector 的时候会复制大量内存，很慢，于是创建 vector 的时候预先分配好内存，接着取到其内部指针，使用内部指针直接写入计算结果

## 使用 CSR 格式存储矩阵数据

稀疏矩阵中的零元素之后就不会再参与计算了，很快啊很快啊。

## 矩阵形式优化

发现把矩阵 `const Matrix &A` 转置一下再乘，可以让矩阵乘法的时候访问的内存更加连续。同时也会导致结果矩阵变成转置之后的形式，需要再对结果矩阵做一次转置。或许把 `const SparseMatrix &B` 用 CSC 格式存储，可以在满足访存连续的同时，省掉这两次转置。不过懒得写了。

## 访存优化

做了一些循环展开。

## 开启编译器 O3 优化

反汇编看了下，发现编译器自动帮我用了上 avx512 的 fma 指令，很酷。
